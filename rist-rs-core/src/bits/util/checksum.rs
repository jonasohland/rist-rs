use log::log;

/// Dirty and slow implementation of 16-bit checksum calculation
pub fn u16(buf: &[u8], skip: Option<usize>) -> u16 {
    let mut result = 0u32;
    for (pos, byte) in buf.iter().enumerate() {
        if pos % 2 == 0 {
            if let Some(s) = skip {
                if s == pos {
                    continue;
                }
            }
            if (pos + 1 < buf.len()) {
                result += u32::from(u16::from_be_bytes(
                    buf[pos..pos + 2]
                        .try_into()
                        .expect("invalid range returned from slice"),
                ));
            } else {
                result += u32::from((*byte as u16) << 8)
            }
            if result > 0xffff {
                result -= 0xffff
            }
        }
    }

    !result as u16
}

mod test {

    use super::u16;

    #[test]
    fn test() {
        // a udp datagram including the pseudo header
        let bytes: [u8; 145] = [
            // pseudo header
            0xc0, 0xa8, 0x00, 0x78, 0xef, 0xff, 0xff, 0xfa, 0x00, 0x11, 0x00, 0x85,
            // udp
            0x9d, 0xa2, 0x07, 0x6c, 0x00, 0x85, 0x7b, 0x31, 0x4d, 0x2d, 0x53, 0x45, 0x41, 0x52,
            0x43, 0x48, 0x20, 0x2a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0x0d,
            0x0a, 0x48, 0x4f, 0x53, 0x54, 0x3a, 0x20, 0x32, 0x33, 0x39, 0x2e, 0x32, 0x35, 0x35,
            0x2e, 0x32, 0x35, 0x35, 0x2e, 0x32, 0x35, 0x30, 0x3a, 0x31, 0x39, 0x30, 0x30, 0x0d,
            0x0a, 0x4d, 0x41, 0x4e, 0x3a, 0x20, 0x22, 0x73, 0x73, 0x64, 0x70, 0x3a, 0x64, 0x69,
            0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x22, 0x0d, 0x0a, 0x4d, 0x58, 0x3a, 0x20, 0x31,
            0x0d, 0x0a, 0x53, 0x54, 0x3a, 0x20, 0x75, 0x72, 0x6e, 0x3a, 0x64, 0x69, 0x61, 0x6c,
            0x2d, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x2d, 0x6f,
            0x72, 0x67, 0x3a, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x3a, 0x64, 0x69, 0x61,
            0x6c, 0x3a, 0x31, 0x0d, 0x0a, 0x0d, 0x0a,
        ];

        assert_eq!(
            super::u16(&bytes, Some(18)),
            u16::from_be_bytes(bytes[18..20].try_into().unwrap())
        );
    }
}
